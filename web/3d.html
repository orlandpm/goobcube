<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Solids + Variables — Three.js Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { display: flex; height: 100%; }
    #menu {
      width: 340px; max-width: 50vw; overflow: auto; padding: 16px;
      border-right: 1px solid #e5e7eb; background: #fafafa;
    }
    #scene { flex: 1; position: relative; }
    #scene canvas { display: block; }
    h2 { font-size: 14px; margin: 0 0 8px; color: #111827; text-transform: uppercase; letter-spacing: .06em; }
    .panel { background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; margin-bottom: 12px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 8px 0; }
    .row label { font-size: 14px; color: #111827; }
    .muted { color: #6b7280; font-size: 12px; }
    .slider { width: 100%; }
    .gridline { position: absolute; inset: 0; pointer-events: none; }
    .solid-title { font-weight: 600; }
    .badge { display:inline-block; padding:2px 6px; font-size:11px; border-radius:999px; background:#eef2ff; color:#3730a3; }
    .vars { font-size:12px; color:#4b5563; }
    .footer { font-size: 12px; color:#6b7280; margin-top: 8px; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/": "https://unpkg.com/three@0.160.0/"
      }
    }
  </script>
</head>
<body>
  <div id="texture-library" style="display: none;">
    <img id="plywood" src="11_bamboo plywood texture-seamless.jpg">
  </div>
  <div id="wrap">
    <aside id="menu">
      <div style="margin-bottom: 16px; text-align: center;">
        <h1 style="font-size: 1.75em; font-weight: 600; margin: 0 0 4px;">GoobCAD</h1>
        <div class="muted">© 2025</div>
      </div>
      <div class="panel">
        <h2>Variables</h2>
        <div id="varControls"></div>
      </div>
      <div class="panel">
        <h2>Solids</h2>
        <div id="solidControls"></div>
      </div>
      <div class="footer">
        • Type supports numbers or expressions (e.g. <code>u*2</code>, <code>1.5+v/2</code>).<br/>
        • Drag to rotate, wheel to zoom, right-drag to pan.
      </div>
    </aside>
    <main id="scene"></main>
  </div>

  <script type="module">
    // ===== Imports =====
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    
    // ===== Helper: basic checkerboard texture (no external assets) =====
    function makeCheckerTexture(size=256, squares=8) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const s = size / squares;
      for (let y=0; y<squares; y++) {
        for (let x=0; x<squares; x++) {
          ctx.fillStyle = ((x + y) % 2 === 0) ? '#e5e7eb' : '#9ca3af';
          ctx.fillRect(x*s, y*s, s, s);
        }
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.anisotropy = 8;
      return tex;
    }

    // ===== Variables definition (name -> {min,max,step, value}) =====
    // You can add more variables or adjust ranges/steps here.
    const variables = {
      u: { min: -5, max: 5, step: 0.1, value: 1.5 },
      v: { min: 0, max: 10, step: 0.1, value: 3 },
      h: { min: 0.5, max: 6, step: 0.1, value: 2.5 },
      r: { min: 0.25, max: 3, step: 0.05, value: 1.0 },
      y_offset: { min: -2, max: 2, step: 0.1, value: 0 },
      drawer_slide: { min: -0.5, max: 7, step: 0.1, value: 0 },
    };

    // ===== Solids definition =====
    // Types: "box", "cylinder", "sphere", "triangular_prism", "group"
    // Positions and sizes can be numbers or string expressions using variables above.
    // Each solid also lists which variables it uses ("vars") so we can surface them clearly.

    const solids = [
      {
        id: "bottom",
        type: "box",
        name: "Rectangular Prism A",
        vars: ["u","v"],
        position: { x: 0, y: 0, z: 0 },
        size: { dx: 12.5, dy: 0.75, dz: 12.5 },
        material: { texture: "plywood" },
        visible: true
      },

      {
        id: "top",
        type: "box",
        name: "Rectangular Prism A",
        vars: ["u","v"],
        position: { x: 0, y: 9.25, z: 0 },
        size: { dx: 12.5, dy: 0.75, dz: 12.5 },
        material: { texture: "plywood" },
        visible: true
      },


      {
        id:"platform",
        type: "group",
        name: "Platform",
        position: { x: 0, y: 0, z: 0 },
        visible: true,
        objects:[
          {
            id:"platform-left",
            type: "box",
            name: "Platform Left",
            vars: [],
            position: {x:0.75, y:3-0.75, z:0.75},
            size: {dx:11.5, dy:0.75, dz:3},
            material: { texture: "plywood" },
            visible: true
          },
          {
            id:"mounting-left",
            type: "box",
            name: "Mounting Left",
            vars: [],
            position: {x:2, y:3, z:1.5},
            size: {dx:9, dy:0.75, dz:1.5},
            material: { texture: "gray" },
            visible: true
          },
          {
            id:"mounting-right",
            type: "box",
            name: "Mounting Right",
            vars: [],
            position: {x:2, y:3, z:12.5 - 1.5 -1.5},
            size: {dx:9, dy:0.75, dz:1.5},
            material: { texture: "gray" },
            visible: true
          },
          {
            id:"platform-right",
            type: "box",
            name: "Platform Right",
            vars: [],
            position: {x:0.75, y:3-0.75, z:12.5 - 0.75 - 3},
            size: {dx:11.5, dy:0.75, dz:3},
            material: { texture: "plywood" },
            visible: true
          }
        ]
      },

      {
        id: "drawer",
        type: "group",
        name: "Drawer",
        vars: ["drawer_slide"],
        position: { x: 0, y: 0, z: 0 },
        visible: true,
        objects: [
          {
            id: "slider-left",
            type: "box",
            name: "Left Slider",
            vars: ["drawer_slide"],
            position: {x:"2+drawer_slide", y:3.25, z:1.75},
            size: {dx:9.75, dy:0.85, dz:1},
            material: { texture: "gray" },
            visible: true
          },
          {
            id:"slider-right",
            type: "box",
            name: "Right Slider",
            vars: ["drawer_slide"],
            position: {x:"2+drawer_slide", y:3.25, z:12.5 - 1.75 - 1},
            size: {dx:9.75, dy:0.85, dz:1},
            material: { texture: "gray" },
            visible: true
          },
          {
            id: "drawer-platform",
            type: "box",
            name: "Rectangular Prism A",
            vars: ["drawer_slide"],
            position: { x: "4.5+drawer_slide", y: 4.1, z: 0.75 },
            size: { dx: 8-0.75, dy: 0.75, dz: 11.5 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "drawer-front",
            type: "box",
            name: "Rectangular Prism A",
            vars :["drawer_slide"],
            position: { x: "11.75+drawer_slide", y: 3.25, z: 0 },
            size: { dx: 0.75, dy: 3.5, dz: 12.5 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "piano-body",
            type: "box",
            name: "Piano Body",
            vars: ["drawer_slide"],
            position: { x: "4.5+drawer_slide", y: 4.85, z: 0.75 },
            size: { dx: 7.25, dy: 1.5, dz: 11.5 },
            material: { color: "#ef4444" }, // red-500
            visible: true
          },
          ...[...Array(15).keys()].map(i => ({
            id: `white-key-${i}`,
            type: "box",
            name: `White Key ${i + 1}`,
            vars: ["drawer_slide"],
            position: { x: "6.75+drawer_slide", y: 6.35, z: 1.25 + i * 0.7 },
            size: { dx: 5, dy: 0.2, dz: 0.7-0.1 },
            material: { color: "#ffffff" },
            visible: true
          })),
          ...[...Array(14).keys()]
            .filter(i => ![2,6,9,13].includes(i % 7))
            .map(i => ({
              id: `black-key-${i}`,
              type: "box",
              name: `Black Key ${i + 1}`,
              vars: ["drawer_slide"],
              position: { x: "6.75+drawer_slide", y: 6.45, z: 1.25 + i * 0.7 + (0.7/2) },
              size: { dx: 3, dy: 0.2, dz: 0.4 },
              material: { color: "#000000" },
              visible: true
            }))
        ]
      },

      {
        id: "right",
        type: "group",
        name: "Right Side",
        vars: [],
        position: { x: 0, y: 0, z: 0 },
        visible: true,
        objects: [
          {
            id: "right-lower",
            type: "box",
            name: "Right Lower Prism",
            vars: [],
            position: { x: 0, y: 0, z: 0 },
            size: { dx: 12.5, dy: 3, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "right-rear",
            type: "box",
            name: "Right Lower Prism",
            vars: [],
            position: { x: 0, y: 3, z: 0 },
            size: { dx: 4.5, dy: 4, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "right-lip",
            type: "box",
            name: "Right Lower Prism",
            vars: [],
            position: { x: 4.5, y: 3, z: 0 },
            size: { dx: 6.5, dy: 0.75, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "right-upper",
            type: "box",
            name: "Right Upper Prism",
            vars: [],
            position: { x: 0, y: 7, z: 0 },
            size: { dx: 12.5, dy: 3, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          }
        ]
      },
      {
        id: "left",
        type: "group",
        name: "Left Side",
        vars: [],
        position: { x: 0, y: 0, z: 0 },
        visible: true,
        objects: [
          {
            id: "left-lower",
            type: "box",
            name: "Left Lower Prism",
            vars: [],
            position: { x: 0, y: 0, z: 11.75 },
            size: { dx: 12.5, dy: 3, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "left-rear",
            type: "box",
            name: "Left Lower Prism",
            vars: [],
            position: { x: 0, y: 3, z: 11.75 },
            size: { dx: 4.5, dy: 4, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "left-lip",
            type: "box",
            name: "Left Lower Prism",
            vars: [],
            position: { x: 4.5, y: 3, z: 11.75 },
            size: { dx: 6.5, dy: 0.75, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          },
          {
            id: "left-upper",
            type: "box",
            name: "Left Upper Prism",
            vars: [],
            position: { x: 0, y: 7, z: 11.75 },
            size: { dx: 12.5, dy: 3, dz: 0.75 },
            material: { texture: "plywood" },
            visible: true
          }
        ]
      },
      {
        id: "back",
        type: "box",
        name: "Rectangular Prism A",
        vars: [],
        position: { x: 0, y: 0, z: 0 },
        size: { dx: 0.75, dy: 12.5, dz: 12.5 },
        material: { texture: "plywood" },
        visible: true
      },
      {
        id: "front-upper",
        type: "box",
        name: "Rectangular Prism A",
        vars :[],
        position: { x: 11.75, y: 7, z: 0 },
        size: { dx: 0.75, dy: 3, dz: 12.5 },
        material: { texture: "plywood" },
        visible: true
      },

      {
        id: "front-lower",
        type: "box",
        name: "Rectangular Prism A",
        vars :[],
        position: { x: 11.75, y: 0, z: 0 },
        size: { dx: 0.75, dy: 3, dz: 12.5 },
        material: { texture: "plywood" },
        visible: true
      },
      // {
      //   id: "group1",
      //   type: "group",
      //   name: "Cylinder & Sphere Group",
      //   vars: ["h", "r", "u", "v", "y_offset"],
      //   position: { x: 0, y: "y_offset", z: 0 },
      //   visible: true,
      //   objects: [
      //     {
      //       id: "cyl1",
      //       type: "cylinder",
      //       name: "Cylinder (axis Y)",
      //       vars: ["h","r","u"],
      //       axis: "y",
      //       position: { x: "-2 + u*0.5", y: "h/2", z: 0 },
      //       size: { radiusTop: "r", radiusBottom: "r", height: "h" },
      //       material: { texture: "checker" },
      //       visible: true
      //     },
      //     {
      //       id: "sph1",
      //       type: "sphere",
      //       name: "Sphere",
      //       vars: ["v","r"],
      //       position: { x: 3, y: "r + 0.01", z: "1 + v*0.2" },
      //       size: { radius: "r" },
      //       material: { color: "#34d399" }, // green-400
      //       visible: true
      //     },
      //   ]
      // },

      // {
      //   id: "box2",
      //   type: "box",
      //   name: "Tall Box",
      //   vars: ["u","h"],
      //   position: { x: "-5.6", y: "0", z: "-3.6 + u*0.4" },
      //   size: { dx: 1.2, dy: "h", dz: 1.2 },
      //   material: { color: "#f472b6" }, // pink-400
      //   visible: true
      // },
      // {
      //   id: "tri1",
      //   type: "triangular_prism",
      //   name: "Triangular Prism",
      //   vars: ["u","v","r"],
      //   position: { x: "u", y: "r", z: "v" },
      //   size: { w: "1+r", d: "1.5+r*0.5", h: "r*2" },
      //   material: { color: "#f59e0b" }, // amber-500
      //   visible: true
      // }
    ];

    // ===== Expression evaluation (safe-ish) =====
    // Supports numbers, + - * / **, parentheses, and variable names.
    // Rejects unexpected characters to reduce eval surface.
    const SAFE_CHARS = /^[\d+\-*/().\sA-Za-z_]+$/;
    function evalExpr(exprOrNumber, scope) {
      if (typeof exprOrNumber === "number") return exprOrNumber;
      const expr = String(exprOrNumber).trim();
      if (!SAFE_CHARS.test(expr)) {
        throw new Error(`Illegal characters in expression: "${expr}"`);
      }
      // Only allow known identifiers (variables) and arithmetic operators.
      // Bind Math for potential future extension if needed (not required here).
      const fn = new Function("vars", `
        with (vars) {
          return (${expr});
        }
      `);
      return fn(scope);
    }

    function numeric(val, scope) {
      const n = evalExpr(val, scope);
      if (!Number.isFinite(n)) throw new Error(`Expression did not resolve to finite number: ${val}`);
      return n;
    }

    // ===== Three.js setup =====
    const sceneEl = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(sceneEl.clientWidth, sceneEl.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    sceneEl.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);

    const camera = new THREE.PerspectiveCamera(50, sceneEl.clientWidth / sceneEl.clientHeight, 0.1, 1000);
    camera.position.set(25, 20, 25);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 4);
    scene.add(dir);

    // Ground + helpers
    const grid = new THREE.GridHelper(40, 40, 0x9ca3af, 0xe5e7eb);
    grid.position.y = 0;
    scene.add(grid);

    const axes = new THREE.AxesHelper(3);
    axes.position.y = 0.01;
    scene.add(axes);

    // ===== Materials cache =====
    const textureLoader = new THREE.TextureLoader();
    const materials = {
      checker: new THREE.MeshStandardMaterial({ map: makeCheckerTexture(), metalness: 0.1, roughness: 0.8 }),
    };
    const imageElements = new Map(); // texture path -> <img> element

    function materialFromSpec(spec) {
      if (spec?.texture) {
        if (spec.texture === "checker") return materials.checker;
        
        // Check if a material for this texture is already cached
        if (materials[spec.texture]) return materials[spec.texture];

        const image = document.getElementById(spec.texture);
        // If image is loaded, create material and cache it
        if (image && image.complete && image.naturalWidth > 0) {
          const texture = new THREE.Texture(image);
          texture.needsUpdate = true;
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.anisotropy = 8;
          const newMat = new THREE.MeshStandardMaterial({
            map: texture,
            metalness: 0.1,
            roughness: 0.85
          });
          materials[spec.texture] = newMat;
          return newMat;
        }
        
        // If image not ready, return a placeholder material
        materials.placeholder = materials.placeholder || new THREE.MeshStandardMaterial({ color: '#ccc' });
        return materials.placeholder;
      }

      const m = new THREE.MeshStandardMaterial({
        color: new THREE.Color(spec?.color ?? "#93c5fd"),
        metalness: 0.1,
        roughness: 0.85
      });
      return m;
    }

    // ===== Build & manage solid meshes =====
    const solidState = new Map(); // id -> {def, mesh}

    function buildGeometry(def, scope) {
      if (def.type === "box") {
        const dx = numeric(def.size.dx, scope);
        const dy = numeric(def.size.dy, scope);
        const dz = numeric(def.size.dz, scope);
        return new THREE.BoxGeometry(dx, dy, dz);
      } else if (def.type === "sphere") {
        const r = numeric(def.size.radius, scope);
        return new THREE.SphereGeometry(r, 32, 16);
      } else if (def.type === "cylinder") {
        const rTop = numeric(def.size.radiusTop, scope);
        const rBot = numeric(def.size.radiusBottom, scope);
        const h = numeric(def.size.height, scope);
        // default along Y; we can rotate later to align axis.
        return new THREE.CylinderGeometry(rTop, rBot, h, 32, 1);
      } else if (def.type === "triangular_prism") {
        const w = numeric(def.size.w, scope);
        const d = numeric(def.size.d, scope);
        const h = numeric(def.size.h, scope);
        const shape = new THREE.Shape();
        shape.moveTo(-w/2, -d/2);
        shape.lineTo(w/2, -d/2);
        shape.lineTo(-w/2, d/2);
        shape.closePath();
        const extrudeSettings = { depth: h, bevelEnabled: false };
        const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geom.translate(0, 0, -h/2); // Center along extrusion axis (z)
        geom.rotateX(Math.PI / 2); // Orient so height is along Y
        return geom;
      } else {
        throw new Error(`Unknown solid type: ${def.type}`);
      }
    }

    function setPositionAndAxis(mesh, def, scope, parentPosition = {x:0, y:0, z:0}) {
      const px = numeric(def.position.x ?? 0, scope) + parentPosition.x;
      const py = numeric(def.position.y ?? 0, scope) + parentPosition.y;
      const pz = numeric(def.position.z ?? 0, scope) + parentPosition.z;
      
      if (def.type === "box") {
        const dx = numeric(def.size.dx, scope);
        const dy = numeric(def.size.dy, scope);
        const dz = numeric(def.size.dz, scope);
        mesh.position.set(px + dx / 2, py + dy / 2, pz + dz / 2);
      } else {
        mesh.position.set(px, py, pz);
      }
      mesh.rotation.set(0, 0, 0);

      if (def.type === "cylinder") {
        const axis = (def.axis ?? "y").toLowerCase();
        if (axis === "x") mesh.rotation.z = Math.PI / 2;
        else if (axis === "z") mesh.rotation.x = Math.PI / 2;
      }
    }

    function ensureSolid(def, parentPosition, parentVisibility = true) {
      const scope = Object.fromEntries(Object.entries(variables).map(([k,v]) => [k, v.value]));
      const isVisible = parentVisibility && !!def.visible;

      if (def.type === "group") {
        const groupPosition = {
          x: numeric(def.position?.x ?? 0, scope) + (parentPosition?.x ?? 0),
          y: numeric(def.position?.y ?? 0, scope) + (parentPosition?.y ?? 0),
          z: numeric(def.position?.z ?? 0, scope) + (parentPosition?.z ?? 0),
        };
        def.objects.forEach(obj => ensureSolid(obj, groupPosition, isVisible));
        return;
      }

      let entry = solidState.get(def.id);
      const geom = buildGeometry(def, scope);
      if (!entry) {
        const mat = materialFromSpec(def.material ?? {});
        const mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = false; mesh.receiveShadow = true;
        scene.add(mesh);
        entry = { def, mesh };
        solidState.set(def.id, entry);
      } else {
        entry.mesh.geometry.dispose();
        entry.mesh.geometry = geom;
        // Always re-evaluate material in case a texture has loaded
        entry.mesh.material = materialFromSpec(def.material ?? {});
      }
      setPositionAndAxis(entry.mesh, def, scope, parentPosition);
      entry.mesh.visible = isVisible;
      entry.mesh.userData.name = def.name ?? def.id;
    }

    function rebuildAllSolids() {
      // Clear out meshes that might be removed if the solids definition changes.
      // A more robust system would track removals, but for now this is simple.
      for (const [id, state] of solidState) {
        if (!solids.some(s => s.id === id || (s.objects && s.objects.some(o => o.id === id)))) {
            state.mesh.geometry.dispose();
            scene.remove(state.mesh);
            solidState.delete(id);
        }
      }
      solids.forEach(def => ensureSolid(def));
      renderer.render(scene, camera);
    }

    // ===== UI: variable sliders =====
    const varControls = document.getElementById('varControls');
    function buildVarControls() {
      varControls.innerHTML = "";
      Object.entries(variables).forEach(([name, spec]) => {
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `
          <label for="var_${name}"><span class="solid-title">${name}</span> <span class="muted">[${spec.min} .. ${spec.max}]</span></label>
          <span class="badge" id="val_${name}">${spec.value}</span>
        `;
        varControls.appendChild(row);

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.className = 'slider';
        slider.id = `var_${name}`;
        slider.min = spec.min;
        slider.max = spec.max;
        slider.step = spec.step ?? 0.01;
        slider.value = spec.value;
        slider.addEventListener('input', () => {
          spec.value = parseFloat(slider.value);
          document.getElementById(`val_${name}`).textContent = spec.value.toFixed(3).replace(/\.?0+$/,'');
          rebuildAllSolids();
        });
        varControls.appendChild(slider);
      });
    }

    // ===== UI: solid toggles + info =====
    const solidControls = document.getElementById('solidControls');
    function buildSolidControls() {
      solidControls.innerHTML = "";
      const buildControlsForList = (solidList, parentElement, level = 0) => {
        solidList.forEach((s) => {
          const panel = document.createElement('div');
          panel.className = 'panel';
          panel.style.marginBottom = '8px';
          panel.style.padding = '10px';
          if (level > 0) {
            panel.style.marginLeft = `${level * 16}px`;
          }

          const row = document.createElement('div');
          row.className = 'row';
          const id = `chk_${s.id}`;
          row.innerHTML = `
            <label for="${id}" class="solid-title">${s.name ?? s.id}</label>
            <input type="checkbox" id="${id}" ${s.visible ? 'checked' : ''}/>
          `;
          panel.appendChild(row);

          const varsLine = document.createElement('div');
          varsLine.className = 'vars';
          if (Array.isArray(s.vars) && s.vars.length) {
            varsLine.textContent = `vars: ${s.vars.join(', ')}`;
          } else {
            varsLine.textContent = 'vars: —';
          }
          panel.appendChild(varsLine);

          if (s.type !== 'group') {
            const pos = s.position ?? {};
            const size = s.size ?? {};
            const details = document.createElement('div');
            details.className = 'muted';
            details.style.marginTop = '6px';
            details.innerHTML = `
              <div>position: x=${pos.x ?? 0}, y=${pos.y ?? 0}, z=${pos.z ?? 0}</div>
              <div>size: ${s.type === 'box'
                  ? `dx=${size.dx}, dy=${size.dy}, dz=${size.dz}`
                  : s.type === 'sphere'
                  ? `radius=${size.radius}`
                  : s.type === 'triangular_prism'
                  ? `w=${size.w}, d=${size.d}, h=${size.h}`
                  : `rTop=${size.radiusTop}, rBot=${size.radiusBottom}, h=${size.height}${s.axis?`, axis=${s.axis}`:''}`
                }
              </div>
            `;
            panel.appendChild(details);
          }

          const chk = row.querySelector('input');
          chk.addEventListener('change', () => {
            s.visible = chk.checked;
            // This visibility toggle is simplistic for groups; it doesn't auto-toggle children.
            // A full implementation might want to propagate visibility.
            if (s.type === 'group') {
                rebuildAllSolids(); // Easiest way to handle group visibility change
            } else {
              const entry = solidState.get(s.id);
              if (entry) entry.mesh.visible = s.visible;
            }
            renderer.render(scene, camera);
          });

          parentElement.appendChild(panel);

          if (s.type === 'group' && Array.isArray(s.objects)) {
            buildControlsForList(s.objects, parentElement, level + 1);
          }
        });
      };
      buildControlsForList(solids, solidControls);
    }

    // ===== Handle texture loading from hardcoded <img> tags =====
    function initializeTextureLoading() {
      const textureLibrary = document.getElementById('texture-library');
      if (!textureLibrary) return;

      const images = textureLibrary.getElementsByTagName('img');
      for (const img of images) {
        if (!img.complete) {
          img.onload = () => {
            console.log(`Texture loaded: ${img.id}`);
            rebuildAllSolids();
          };
          img.onerror = () => console.error(`Failed to load texture: ${img.id}`);
        }
      }
    }

    // ===== Resize handling =====
    function onResize() {
      const w = sceneEl.clientWidth;
      const h = sceneEl.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      renderer.render(scene, camera);
    }
    window.addEventListener('resize', onResize);
    // In case the sidebar width changes with scrollbar, reflow shortly after load:
    setTimeout(onResize, 50);

    // ===== Animate =====
    function animate() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // ===== Init =====
    initializeTextureLoading();
    buildVarControls();
    buildSolidControls();
    rebuildAllSolids();
    animate();

    // Expose for console tinkering if desired:
    window.__solids = solids;
    window.__vars = variables;
  </script>
</body>
</html>
